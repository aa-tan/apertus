{"/":{"title":"Codex Omnia","content":"\n\u003e The only true wisdom is in knowing you know nothing\n","lastmodified":"2023-07-30T09:03:43.960877832Z","tags":[]},"/notes/Game-Loop":{"title":"Game Loop","content":"# Game Loop\nThe Game Loop defines the invidual steps a [[Game Engine|game engine]] executes in order to produce a working game.\n\nThere are three main steps that repeat as the game runs.\n\n```mermaid\ngraph TD\n\n\ta(Input) --\u003e b(Process)\n\t\n\tb --\u003e c(Render)\n\t\n\tc --\u003e a\n ```\n\n## Input\nUser input can come in many forms. The first step of the game loop is typically to recieve input from a player that can then be processed by the engine.\n\nExamples of potential inputs include:\n- Button presses\n- Mouse movement\n- Gyro sensors like a phone tilting\n- Sound activation from a microphone\n\n## Process\nOnce the game engine receives input, it can now process or update the state of the game.\n\nExamples of what can be updated:\n- Object physics\n- Enemy Health\n- Player Experience\n\n## Render\nNow that game state has been updated, the final step is to display the new game state on the screen. After rendering, the game loop returns to the initial state of reading inputs and continues looping until the game terminates.\n\n# Implementations\nThe game loop runs continously as the driving force of the game engine. In modern computing however, machines come with different specifications that can affect performance in varying ways.\n\nThis performance variation can have an affect on the game loop depending on how fast or slow a machine runs. For example as video games are largely a visual medium, the render step within a gameloop is typically tied closely to the speed at which [[Frame|frames]] are rendered. A game with logic tied directly to FPS may have enemies moving faster on a high-end machine compared to a low-end machine.\n\nTo handle this, there are two main methods of implementing a game loop, both with their own benefits and flaws. Deciding on which to use for your game engine depends on the type of game and target hardware being developed for.\n\n## Fixed Time-step\nasdf\n## Variable Time-step\nasdf","lastmodified":"2023-07-30T09:03:43.960877832Z","tags":["gamedev"]},"/notes/Vector":{"title":"Vector","content":"# Vector\nA vector has [[magnitude]] and direction. In a 2D plane, this can be represented by a coordinate points. Mathematic notation uses bold to indicate a **vector** and vertical bars to represent ||**magnitude**|| of a vector.\n\n#fix The vector (x,y) has a magnitude and direction relative to coordinate point (0,0).\n```chart\ntype: line\nlabels: [0,4]\nseries:\n  - title: Vector z\n    data: [0,2]\ntension: 0\nwidth: 58%\nlabelColors: false\nfill: false\nbeginAtZero: true\n```\nThe vector **z** (4,3) in the above figure has a direction relative to 0,0. With a magnitude defined by the length. Magnitude can be calculated as:\n $$||\\vec{z}|| = \\sqrt{\\vec{x}^2+\\vec{y}^2}$$\n\u003e [!example]-\n\u003e $||\\vec{z}|| = \\sqrt{4^2+3^2}$\u003cbr\u003e\n\u003e $||\\vec{z}|| = \\sqrt{25}$\u003cbr\u003e\n\u003e $||\\vec{z}|| = 5$\n \n\n### Normalized Vector\nA Normalized vector is a vector with the same direction but a magnitude of 1. It is calculated as:\n$$Normal(x) = \\frac{x}{||x||}$$\n\n# Mathematical Operations\nBasic operations can be applied to vectors in order to create new vectors. \nIn all examples, assume the following:\n$\\vec{a} = (2,5)$ and $\\vec{b} = (6,7)$\n\n### Addition\nVector addition adds corresponding indices with each other.\n$$(x_1,y_1)+(x_2,y_2)=(x_1+x_2,y_1+y_2)$$\n\u003e[!example]-\n$\\vec{c} = \\vec{a}+\\vec{b}$\n$\\vec{c} = (2,5) + (6,7)$\n$\\vec{c} = (2+6, 5+7)$\n$\\vec{c} = (8,12)$\n\n### Subtraction\nVector subtraction involves reversing the second vector and then performing addition.\n$$(x_1,y_1)-(x_2,y_2) = (x_1,y_1) + (-x_2,-y_2)$$\n\u003e[!example]-\n$\\vec{c} = (2,5)-(6,7)$\n$\\vec{c} = (2,5)+(-6,-7)$\n$\\vec{c} = (2-6,5-7)$\n$\\vec{c} = (-4,-2)$\n\n## Scaling\nScaling a vector can be achieved by multiplying the vector with a [[Scalar]].\n$$(x_1,y_1)*||\\vec{z}|| = (x_1*||\\vec{z}||, y_1*||\\vec{z}||)$$\n\u003e[!example]-\n\u003eAssume scalar $||\\vec{z}|| = 3$\n\u003e$\\vec{c} = \\vec{a} * ||\\vec{z}||$\n\u003e$\\vec{c} = (2,5) * 3$\n\u003e$\\vec{c} = (2*3, 5*3)$\n\u003e$\\vec{c} = (6, 15)$\n\u003e$\\vec{c}=\\vec{a}$\n\n## Dot Product\nThe Dot Product is a method of multiplying two vectors to return a scalar. It can be used to calculate a [[Kinematics|reflection angle]] in [[2D Space]].\n\nAssume θ as the angle between vectors $\\vec{a}$ and $\\vec{b}$\n$$\\vec{a}·\\vec{b} = ||\\vec{a}|| * ||\\vec{b}|| * cos(θ)$$\n","lastmodified":"2023-07-30T09:03:43.960877832Z","tags":["math","physics"]}}